# Azure DevOps CI/CD Pipeline for mseONE PoC
#test
# Fixed Docker task warning and enhanced with GraphQL test results in notifications

trigger:
  branches:
    include:
      - main
      - develop
  paths:
    exclude:
      - README.md
      - docs/*
      - '*.md'

pr:
  branches:
    include:
      - main
  paths:
    exclude:
      - README.md
      - docs/*
      - '*.md'

# Pipeline variables
variables:
  - group: poc-variables  # Variable group created in Azure DevOps
  - name: imageTag
    value: '$(Build.BuildNumber)'
  - name: imageName
    value: 'pocapi'
  - name: pythonVersion
    value: '3.11'
  - name: vmImageName
    value: 'ubuntu-latest'
  # GraphQL test results storage
  - name: graphqlTestResults
    value: ''
  - name: deploymentStatus
    value: 'Unknown'

pool:
  vmImage: $(vmImageName)

stages:
  # Stage 1: Build and Test
  - stage: BuildAndTest
    displayName: 'Build and Test'
    jobs:
      - job: TestApplication
        displayName: 'Test Python Application'
        steps:
          # Set up Python
          - task: UsePythonVersion@0
            inputs:
              versionSpec: '$(pythonVersion)'
              addToPath: true
              architecture: 'x64'
            displayName: 'Use Python $(pythonVersion)'

          # Cache pip dependencies
          - task: Cache@2
            inputs:
              key: 'python | "$(Agent.OS)" | requirements.txt'
              restoreKeys: |
                python | "$(Agent.OS)"
                python
              path: $(Pipeline.Workspace)/.pip
            displayName: 'Cache pip packages'

          # Install dependencies
          - script: |
              python -m pip install --upgrade pip
              python -m pip install --cache-dir $(Pipeline.Workspace)/.pip -r requirements.txt
            displayName: 'Install Python dependencies'

          # Run linting with Ruff
          - script: |
              ruff check . --output-format=junit > ruff-results.xml || true
              ruff check . --output-format=github
            displayName: 'Run Ruff linting'
            continueOnError: 'true'

          # Publish linting results
          - task: PublishTestResults@2
            inputs:
              testResultsFiles: 'ruff-results.xml'
              testRunTitle: 'Linting Results (Ruff)'
              failTaskOnFailedTests: false
              mergeTestResults: true
            displayName: 'Publish linting results'
            condition: always()

          # Set environment variables for testing
          - script: |
              echo "Setting up test environment variables"
              export APP_ENV=local
              export COSMOS_URI=https://test.documents.azure.com:443/
              export COSMOS_KEY=fake_key_for_testing
              export COSMOS_DB=testdb
              export COSMOS_CONTAINER=testcontainer
              export STORAGE_ACCOUNT=testaccount
              export STORAGE_KEY=fake_storage_key
            displayName: 'Set test environment variables'

          # Run tests with coverage
          - script: |
              export APP_ENV=local
              export COSMOS_URI=https://test.documents.azure.com:443/
              export COSMOS_KEY=fake_key_for_testing
              export COSMOS_DB=testdb
              export COSMOS_CONTAINER=testcontainer
              export STORAGE_ACCOUNT=testaccount
              export STORAGE_KEY=fake_storage_key
              
              python -m pytest --maxfail=5 --tb=short -v \
                --junitxml=pytest-results.xml \
                --cov=api \
                --cov-report=xml:coverage.xml \
                --cov-report=html:htmlcov \
                --cov-report=term-missing \
                tests/
            displayName: 'Run pytest with coverage'
            continueOnError: 'true'

          # Publish test results
          - task: PublishTestResults@2
            inputs:
              testResultsFiles: 'pytest-results.xml'
              testRunTitle: 'Python Unit Tests'
              failTaskOnFailedTests: false
              mergeTestResults: true
            displayName: 'Publish test results'
            condition: always()

          # Publish code coverage
          - task: PublishCodeCoverageResults@2
            inputs:
              summaryFileLocation: 'coverage.xml'
              pathToSources: '$(System.DefaultWorkingDirectory)'
              failIfCoverageEmpty: false
            displayName: 'Publish code coverage'
            condition: always()

  # Stage 2: Build and Push Docker Image - FIXED VERSION
  - stage: BuildImage
    displayName: 'Build Docker Image'
    dependsOn: BuildAndTest
    condition: and(succeededOrFailed(), or(eq(variables['Build.SourceBranch'], 'refs/heads/main'), startsWith(variables['Build.SourceBranch'], 'refs/heads/feature/')))
    jobs:
      - job: BuildPushImage
        displayName: 'Build and Push to ACR'
        steps:
          # FIXED: Updated Docker task configuration to eliminate warning
          - task: Docker@2
            inputs:
              containerRegistry: 'acr-connection'
              repository: '$(imageName)'
              command: 'buildAndPush'
              Dockerfile: 'Dockerfile'
              tags: |
                $(imageTag)
                latest
              # FIXED: Add these properties to prevent the warning
              addPipelineData: false
              addBaseImageData: false
            displayName: 'Build and push Docker image'

          # Verify image was built
          - task: PowerShell@2
            inputs:
              targetType: 'inline'
              script: |
                Write-Host "üîç Verifying Docker build..."
                docker images $(ACR_LOGIN_SERVER)/$(imageName):$(imageTag)
                Write-Host "‚úÖ Image verification complete"
            displayName: 'Verify Docker Image'

          # Copy deployment artifacts
          - task: CopyFiles@2
            inputs:
              sourceFolder: '$(Build.SourcesDirectory)'
              contents: |
                azure-pipelines.yml
                Dockerfile
                README.md
              targetFolder: '$(Build.ArtifactStagingDirectory)'
              cleanTargetFolder: true
            displayName: 'Copy deployment artifacts'

          # Publish build artifacts
          - task: PublishBuildArtifacts@1
            inputs:
              pathToPublish: '$(Build.ArtifactStagingDirectory)'
              artifactName: 'drop'
              artifactType: 'Container'
            displayName: 'Publish build artifacts'

  # Stage 3: Deploy to Production with Enhanced GraphQL Testing
  - stage: DeployProduction
    displayName: 'Deploy to Production'
    dependsOn: BuildImage
    condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/main'))
    jobs:
      - deployment: DeployToWebApp
        displayName: 'Deploy to Azure Web App'
        environment: 'production'
        strategy:
          runOnce:
            deploy:
              steps:
                # Deploy to Azure Web App for Containers
                - task: AzureWebAppContainer@1
                  inputs:
                    azureSubscription: 'azure-connection'
                    appName: '$(WEBAPP_NAME)'
                    resourceGroupName: '$(RESOURCE_GROUP)'
                    imageName: '$(ACR_LOGIN_SERVER)/$(imageName):$(imageTag)'
                    containerCommand: 'uvicorn api.main:app --host 0.0.0.0 --port 8080'
                    appSettings: '-APP_ENV azure -AZURE_TENANT_ID $(AZURE_TENANT_ID) -AZURE_AUDIENCE $(AZURE_AUDIENCE) -COSMOS_URI $(COSMOS_URI) -COSMOS_KEY $(COSMOS_KEY) -COSMOS_DB $(COSMOS_DB) -COSMOS_CONTAINER $(COSMOS_CONTAINER) -STORAGE_ACCOUNT $(STORAGE_ACCOUNT) -STORAGE_KEY $(STORAGE_KEY) -WEBSITES_PORT 8080 -DOCKER_REGISTRY_SERVER_URL https://$(ACR_LOGIN_SERVER)'
                  displayName: 'Deploy to Azure Web App'

                # Wait for deployment to stabilize
                - task: AzureAppServiceManage@0
                  inputs:
                    azureSubscription: 'azure-connection'
                    WebAppName: '$(WEBAPP_NAME)'
                    ResourceGroupName: '$(RESOURCE_GROUP)'
                    Action: 'Start Azure App Service'
                  displayName: 'Ensure Web App is running'

                # Health check with retry logic
                - task: PowerShell@2
                  inputs:
                    targetType: 'inline'
                    script: |
                      $healthUrl = "https://$(WEBAPP_NAME).azurewebsites.net/healthz"
                      $maxAttempts = 12
                      $attempt = 1
                      $success = $false
                      
                      Write-Host "üè• Checking application health at: $healthUrl"
                      
                      do {
                          try {
                              Write-Host "‚è±Ô∏è  Health check attempt $attempt of $maxAttempts"
                              $response = Invoke-RestMethod -Uri $healthUrl -Method Get -TimeoutSec 30 -ErrorAction Stop
                              
                              if ($response.status -eq "ok") {
                                  Write-Host "‚úÖ Application is healthy!"
                                  Write-Host "üìä Health details:" 
                                  Write-Host ($response | ConvertTo-Json -Depth 3)
                                  $success = $true
                                  break
                              }
                              else {
                                  Write-Warning "‚ö†Ô∏è Application status: $($response.status)"
                              }
                          }
                          catch {
                              Write-Warning "‚ùå Health check failed: $($_.Exception.Message)"
                          }
                          
                          if ($attempt -lt $maxAttempts) {
                              Write-Host "‚åõ Waiting 15 seconds before next attempt..."
                              Start-Sleep -Seconds 15
                          }
                          
                          $attempt++
                      } while ($attempt -le $maxAttempts)
                      
                      if (-not $success) {
                          Write-Error "üí• Application failed health checks after $maxAttempts attempts"
                          exit 1
                      }
                      
                      # Set pipeline variable for email notification
                      Write-Host "##vso[task.setvariable variable=deploymentStatus]Healthy"
                    failOnStderr: true
                  displayName: 'Health Check with Retry'

                # Enhanced GraphQL Test with Results Capture
                - task: PowerShell@2
                  inputs:
                    targetType: 'inline'
                    script: |
                      Write-Host "üîë Obtaining Azure AD token for GraphQL testing..."
                      
                      # Initialize test results object
                      $testResults = @{
                          timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss UTC"
                          tests = @()
                          summary = @{
                              total = 0
                              passed = 0
                              failed = 0
                              warnings = 0
                          }
                      }
                      
                      # Azure AD credentials
                      $tenantId = "$(AZURE_TENANT_ID)"
                      $clientId = "$(AZURE_CLIENT_ID)" 
                      $clientSecret = "$(AZURE_CLIENT_SECRET)"
                      $resource = "$(RESOURCE)"
                      
                      if (-not $clientSecret -or $clientSecret.StartsWith('$(')) {
                          Write-Error "‚ùå CLIENT_SECRET not configured in pipeline variables"
                          exit 1
                      }
                      
                      try {
                          # Get OAuth token
                          Write-Host "üåê Requesting token from Azure AD..."
                          $tokenUrl = "https://login.microsoftonline.com/$tenantId/oauth2/v2.0/token"
                          
                          $tokenBody = @{
                              client_id = $clientId
                              scope = "$resource/.default"
                              client_secret = $clientSecret
                              grant_type = "client_credentials"
                          }
                          
                          $tokenResponse = Invoke-RestMethod -Uri $tokenUrl -Method Post -Body $tokenBody -ContentType "application/x-www-form-urlencoded" -TimeoutSec 30
                          
                          if ($tokenResponse.access_token) {
                              Write-Host "‚úÖ Successfully obtained Azure AD access token"
                              $accessToken = $tokenResponse.access_token
                              Write-Host "üîç Token expires in: $($tokenResponse.expires_in) seconds"
                          } else {
                              Write-Error "‚ùå No access token received"
                              exit 1
                          }
                          
                      } catch {
                          Write-Error "‚ùå Failed to obtain Azure AD token: $($_.Exception.Message)"
                          exit 1
                      }
                      
                      # Test GraphQL endpoint
                      Write-Host ""
                      Write-Host "üöÄ Testing GraphQL endpoint: https://$(WEBAPP_NAME).azurewebsites.net/graphql"
                      $graphqlUrl = "https://$(WEBAPP_NAME).azurewebsites.net/graphql"
                      
                      $headers = @{
                          "Content-Type" = "application/json"
                          "Authorization" = "Bearer $accessToken"
                      }
                      
                      # Test 1: Schema introspection
                      Write-Host "üìã Test 1: Schema introspection"
                      $testResults.summary.total++
                      try {
                          $schemaQuery = @{
                              query = "{ __schema { queryType { name } mutationType { name } } }"
                          } | ConvertTo-Json -Compress
                          
                          $schemaResponse = Invoke-RestMethod -Uri $graphqlUrl -Method Post -Body $schemaQuery -Headers $headers -TimeoutSec 30
                          
                          if ($schemaResponse.data -and $schemaResponse.data.__schema) {
                              Write-Host "‚úÖ Schema introspection successful"
                              Write-Host "   Query type: $($schemaResponse.data.__schema.queryType.name)"
                              Write-Host "   Mutation type: $($schemaResponse.data.__schema.mutationType.name)"
                              
                              $testResults.tests += @{
                                  name = "Schema Introspection"
                                  status = "PASSED"
                                  details = "Query type: $($schemaResponse.data.__schema.queryType.name), Mutation type: $($schemaResponse.data.__schema.mutationType.name)"
                                  response_time = "< 30s"
                              }
                              $testResults.summary.passed++
                          } else {
                              throw "Unexpected schema response structure"
                          }
                      } catch {
                          Write-Warning "‚ö†Ô∏è Schema introspection failed: $($_.Exception.Message)"
                          $testResults.tests += @{
                              name = "Schema Introspection"
                              status = "FAILED"
                              details = $_.Exception.Message
                              response_time = "timeout/error"
                          }
                          $testResults.summary.failed++
                      }
                      
                      # Test 2: Project Summary Query
                      Write-Host ""
                      Write-Host "üìã Test 2: Project Summary Query"
                      $testResults.summary.total++
                      try {
                          $projectSummaryQuery = @{
                              query = "{ projectSummary { totalProjects activeProjects archivedProjects draftProjects completedProjects } }"
                          } | ConvertTo-Json -Compress
                          
                          $summaryResponse = Invoke-RestMethod -Uri $graphqlUrl -Method Post -Body $projectSummaryQuery -Headers $headers -TimeoutSec 30
                          
                          if ($summaryResponse.data -and $summaryResponse.data.projectSummary) {
                              Write-Host "‚úÖ Project Summary query successful"
                              $summary = $summaryResponse.data.projectSummary
                              Write-Host "   Total Projects: $($summary.totalProjects)"
                              Write-Host "   Active: $($summary.activeProjects)"
                              Write-Host "   Archived: $($summary.archivedProjects)" 
                              Write-Host "   Draft: $($summary.draftProjects)"
                              Write-Host "   Completed: $($summary.completedProjects)"
                              
                              $testResults.tests += @{
                                  name = "Project Summary Query"
                                  status = "PASSED"
                                  details = "Total: $($summary.totalProjects) projects (Active: $($summary.activeProjects), Archived: $($summary.archivedProjects), Draft: $($summary.draftProjects), Completed: $($summary.completedProjects))"
                                  response_time = "< 30s"
                              }
                              $testResults.summary.passed++
                          } else {
                              throw "Project summary query returned unexpected format"
                          }
                      } catch {
                          Write-Warning "‚ö†Ô∏è Project summary query failed: $($_.Exception.Message)"
                          $testResults.tests += @{
                              name = "Project Summary Query"
                              status = "FAILED"
                              details = $_.Exception.Message
                              response_time = "timeout/error"
                          }
                          $testResults.summary.failed++
                      }
                      
                      # Test 3: Projects List Query
                      Write-Host ""
                      Write-Host "üìã Test 3: Projects List Query (first 5)"
                      $testResults.summary.total++
                      try {
                          $projectsListQuery = @{
                              query = "{ projects(first: 5) { totalCount edges { node { id name status createdAt } } pageInfo { hasNextPage } } }"
                          } | ConvertTo-Json -Compress
                          
                          $listResponse = Invoke-RestMethod -Uri $graphqlUrl -Method Post -Body $projectsListQuery -Headers $headers -TimeoutSec 30
                          
                          if ($listResponse.data -and $listResponse.data.projects) {
                              Write-Host "‚úÖ Projects list query successful"
                              $projects = $listResponse.data.projects
                              Write-Host "   Total Count: $($projects.totalCount)"
                              Write-Host "   Retrieved: $($projects.edges.Count) projects"
                              Write-Host "   Has Next Page: $($projects.pageInfo.hasNextPage)"
                              
                              $sampleProject = if ($projects.edges.Count -gt 0) { $projects.edges[0].node.name + " (" + $projects.edges[0].node.status + ")" } else { "No projects" }
                              
                              $testResults.tests += @{
                                  name = "Projects List Query"
                                  status = "PASSED"
                                  details = "Retrieved $($projects.edges.Count) of $($projects.totalCount) total projects. Sample: $sampleProject"
                                  response_time = "< 30s"
                              }
                              $testResults.summary.passed++
                          } else {
                              throw "Projects list query returned unexpected format"
                          }
                      } catch {
                          Write-Warning "‚ö†Ô∏è Projects list query failed: $($_.Exception.Message)"
                          $testResults.tests += @{
                              name = "Projects List Query"
                              status = "FAILED"
                              details = $_.Exception.Message
                              response_time = "timeout/error"
                          }
                          $testResults.summary.failed++
                      }
                      
                      # Test 4: Create Project Mutation (if no critical failures)
                      if ($testResults.summary.failed -eq 0) {
                          Write-Host ""
                          Write-Host "üìã Test 4: Create Project Mutation"
                          $testResults.summary.total++
                          try {
                              $createMutation = @{
                                  query = 'mutation { createProject(input: { name: "Pipeline Test Project", description: "Created during deployment pipeline", status: DRAFT }) { success error project { id name status } } }'
                              } | ConvertTo-Json -Compress
                              
                              $createResponse = Invoke-RestMethod -Uri $graphqlUrl -Method Post -Body $createMutation -Headers $headers -TimeoutSec 30
                              
                              if ($createResponse.data -and $createResponse.data.createProject -and $createResponse.data.createProject.success) {
                                  Write-Host "‚úÖ Create project mutation successful"
                                  $project = $createResponse.data.createProject.project
                                  Write-Host "   Created project: $($project.name) (ID: $($project.id))"
                                  
                                  $testResults.tests += @{
                                      name = "Create Project Mutation"
                                      status = "PASSED"
                                      details = "Created project '$($project.name)' with ID: $($project.id)"
                                      response_time = "< 30s"
                                  }
                                  $testResults.summary.passed++
                              } else {
                                  $errorMsg = if ($createResponse.data.createProject.error) { $createResponse.data.createProject.error } else { "Unknown error" }
                                  throw "Create mutation failed: $errorMsg"
                              }
                          } catch {
                              Write-Warning "‚ö†Ô∏è Create project mutation failed: $($_.Exception.Message)"
                              $testResults.tests += @{
                                  name = "Create Project Mutation"
                                  status = "FAILED"
                                  details = $_.Exception.Message
                                  response_time = "timeout/error"
                              }
                              $testResults.summary.failed++
                          }
                      } else {
                          Write-Host "üö´ Skipping Create Project Mutation due to previous test failures"
                      }
                      
                      # Generate summary
                      Write-Host ""
                      Write-Host "üìä GraphQL Test Results Summary:"
                      Write-Host "   Total Tests: $($testResults.summary.total)"
                      Write-Host "   Passed: $($testResults.summary.passed)"
                      Write-Host "   Failed: $($testResults.summary.failed)"
                      Write-Host "   Success Rate: $(if($testResults.summary.total -gt 0) { [math]::Round(($testResults.summary.passed / $testResults.summary.total) * 100, 1) } else { 0 })%"
                      
                      # Convert test results to JSON and set pipeline variable for email
                      $testResultsJson = ($testResults | ConvertTo-Json -Depth 4 -Compress)
                      Write-Host "##vso[task.setvariable variable=graphqlTestResults]$testResultsJson"
                      
                      if ($testResults.summary.failed -eq 0) {
                          Write-Host "üéâ All GraphQL tests passed!"
                      } else {
                          Write-Host "‚ö†Ô∏è Some GraphQL tests failed, but deployment continues"
                      }
                    failOnStderr: false
                  displayName: 'Enhanced GraphQL Testing with Results Capture'
                  continueOnError: true

  # Stage 4: Enhanced Post-Deployment with Email Notification
  - stage: PostDeployment
    displayName: 'Post-Deployment Activities'
    dependsOn: DeployProduction
    condition: always()
    jobs:
      - job: NotifyAndCleanup
        displayName: 'Notifications and Cleanup'
        steps:
          # Deployment summary with GraphQL test results
          - task: PowerShell@2
            inputs:
              targetType: 'inline'
              script: |
                $buildStatus = "$(Agent.JobStatus)"
                $buildNumber = "$(Build.BuildNumber)"
                $sourceBranch = "$(Build.SourceBranchName)"
                $commitId = "$(Build.SourceVersion)".Substring(0,8)
                $commitMessage = "$(Build.SourceVersionMessage)"
                $triggeredBy = "$(Build.RequestedFor)"
                $deploymentStatus = "$(deploymentStatus)"
                $graphqlResultsJson = "$(graphqlTestResults)"
                
                # Parse GraphQL test results
                $graphqlResults = $null
                $graphqlSummary = ""
                try {
                    if ($graphqlResultsJson -and $graphqlResultsJson -ne "" -and -not $graphqlResultsJson.StartsWith('$(')) {
                        $graphqlResults = $graphqlResultsJson | ConvertFrom-Json
                        $successRate = if($graphqlResults.summary.total -gt 0) { [math]::Round(($graphqlResults.summary.passed / $graphqlResults.summary.total) * 100, 1) } else { 0 }
                        $graphqlSummary = "GraphQL Tests: $($graphqlResults.summary.passed)/$($graphqlResults.summary.total) passed ($successRate%)"
                    } else {
                        $graphqlSummary = "GraphQL Tests: Not executed or failed to capture results"
                    }
                } catch {
                    $graphqlSummary = "GraphQL Tests: Error parsing results"
                }
                
                Write-Host "üöÄ============================================üöÄ"
                Write-Host "üìã DEPLOYMENT SUMMARY"
                Write-Host "üöÄ============================================üöÄ"
                Write-Host "üìä Status: $buildStatus"
                Write-Host "üî¢ Build: $buildNumber"  
                Write-Host "üåø Branch: $sourceBranch"
                Write-Host "üìù Commit: $commitId"
                Write-Host "üí¨ Message: $commitMessage"
                Write-Host "üë§ Triggered by: $triggeredBy"
                Write-Host "üè• Health Status: $deploymentStatus"
                Write-Host "üß™ $graphqlSummary"
                Write-Host "üïí Completed: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss UTC')"
                Write-Host ""
                Write-Host "üåê Application URLs:"
                Write-Host "   üè† Root: https://$(WEBAPP_NAME).azurewebsites.net"
                Write-Host "   üöÄ GraphQL: https://$(WEBAPP_NAME).azurewebsites.net/graphql"  
                Write-Host "   üè• Health: https://$(WEBAPP_NAME).azurewebsites.net/healthz"
                Write-Host ""
                Write-Host "üê≥ Docker Image: $(ACR_LOGIN_SERVER)/$(imageName):$(imageTag)"
                
                # Detailed GraphQL Test Results
                if ($graphqlResults) {
                    Write-Host ""
                    Write-Host "üß™ GraphQL Test Details:"
                    Write-Host "   Executed at: $($graphqlResults.timestamp)"
                    foreach ($test in $graphqlResults.tests) {
                        $statusIcon = if ($test.status -eq "PASSED") { "‚úÖ" } else { "‚ùå" }
                        Write-Host "   $statusIcon $($test.name): $($test.status)"
                        Write-Host "      Details: $($test.details)"
                        Write-Host "      Response Time: $($test.response_time)"
                    }
                }
                
                Write-Host "üöÄ============================================üöÄ"
                
                if ($buildStatus -eq "Succeeded") {
                    Write-Host "üéâ DEPLOYMENT COMPLETED SUCCESSFULLY! üéâ"
                    Write-Host "Your API is now live and ready to use!"
                } elseif ($buildStatus -eq "SucceededWithIssues") {
                    Write-Host "‚ö†Ô∏è DEPLOYMENT COMPLETED WITH WARNINGS ‚ö†Ô∏è"
                    Write-Host "Please review the pipeline logs for details."
                } else {
                    Write-Host "üí• DEPLOYMENT FAILED OR WAS CANCELLED üí•" 
                    Write-Host "Please check the pipeline logs for error details."
                }
                Write-Host "üöÄ============================================üöÄ"
            displayName: 'Deployment Summary with GraphQL Results'

          # Cleanup old images (optional)
          - task: PowerShell@2
            inputs:
              targetType: 'inline'
              script: |
                Write-Host "üßπ Cleanup tasks completed"
                Write-Host "Note: Consider implementing ACR cleanup policies to manage old images"
                Write-Host "https://docs.microsoft.com/en-us/azure/container-registry/container-registry-retention-policy"
                
                # Optional: Clean up old images if ACR gets too full
                # This would require additional permissions and logic
                Write-Host ""
                Write-Host "To implement automated cleanup:"
                Write-Host "1. Enable ACR retention policies"
                Write-Host "2. Use 'az acr repository delete' commands"
                Write-Host "3. Keep last N builds or images older than X days"
            displayName: 'Cleanup Notes'
            condition: always()

          - task: PowerShell@2
            inputs:
              targetType: 'inline'
              script: |
                Write-Host "üöÄ Triggering post-deployment Logic App..."
                
                $logicAppUrl = "https://prod-14.northcentralus.logic.azure.com:443/workflows/1ab32016b4b84baab559dc2d42bf6ea6/triggers/When_a_HTTP_request_is_received/paths/invoke?api-version=2016-10-01&sp=%2Ftriggers%2FWhen_a_HTTP_request_is_received%2Frun&sv=1.0&sig=YWEwwph--xz9zrJyM81e2x2ecyRjBD6GaiRxmDbeL8Y"
                
                # Build comprehensive payload with all deployment details
                $payload = @{
                    deploymentId = "$(Build.BuildNumber)"
                    commitId = "$(Build.SourceVersion)".Substring(0, 8)  # First 8 characters
                    commitMessage = "$(Build.SourceVersionMessage)"
                    deployedBy = "$(Build.RequestedFor)"
                    deploymentTime = (Get-Date).ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ssZ")
                    environment = "production"
                    imageTag = "$(imageTag)"
                    triggerSource = "AzureDevOpsPipeline"
                    sourceBranch = "$(Build.SourceBranchName)"
                    buildUrl = "$(System.TeamFoundationCollectionUri)$(System.TeamProject)/_build/results?buildId=$(Build.BuildId)"
                    appHealthUrl = "https://$(WEBAPP_NAME).azurewebsites.net/healthz"
                    repositoryName = "$(Build.Repository.Name)"
                    repositoryUrl = "$(Build.Repository.Uri)"
                    buildDefinitionName = "$(Build.DefinitionName)"
                    agentName = "$(Agent.Name)"
                    buildReason = "$(Build.Reason)"
                } | ConvertTo-Json -Depth 3
                
                Write-Host "üì¶ Payload being sent:"
                Write-Host $payload
                
                try {
                    $response = Invoke-RestMethod -Uri $logicAppUrl -Method POST -Body $payload -ContentType "application/json" -TimeoutSec 30
                    Write-Host "‚úÖ Logic App triggered successfully"
                    Write-Host "Response: $($response | ConvertTo-Json)"
                } catch {
                    Write-Warning "‚ö†Ô∏è Failed to trigger Logic App: $($_.Exception.Message)"
                    Write-Host "Error details: $($_.ErrorDetails.Message)"
                    # Don't fail the pipeline if Logic App trigger fails
                }
            displayName: 'Trigger Post-Deployment Logic App with Full Details and values'
            condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/main'))
